#include <fstream>
#include <iostream>
#include <memory>
#include <string>

#include "serialization_xml.h"

namespace po = boost::program_options;

void writeHeader(std::ofstream &out, const StateDefinition &state)
{
	out << "// GENERATED HEADER - generated by GamestateSerializeGen - do not modify directly\n\n";
	out << "#pragma once\n\n";
	out << "#include \"game/state/gamestate.h\"\n\n";
	out << "#include \"game/state/gamestate_serialize.h\"\n\n";
	out << "namespace OpenApoc {\n\n";
	out << "static constexpr const char* const GAMESTATE_SERIALIZATION_VERSION = \""
	    << state.hashString << "\";\n";
	out << "class SerializationNode;\n\n";
	for (auto &object : state.objects)
	{
		if (object.external == false)
			continue;
		out << "void serializeIn(const GameState *, SerializationNode* node, " << object.name
		    << " &obj);\n";
		out << "void serializeOut(SerializationNode* node, const " << object.name << " &obj, const "
		    << object.name << " &ref);\n";
		out << "bool operator==(const " << object.name << " &a, const " << object.name << " &b);\n";
		out << "bool operator!=(const " << object.name << " &a, const " << object.name
		    << " &b);\n\n";
	}

	for (auto &e : state.enums)
	{
		if (e.external == false)
			continue;
		out << "void serializeIn(const GameState *, SerializationNode* node, " << e.name
		    << " &val);\n";
		out << "void serializeOut(SerializationNode* node, const " << e.name << " &val, const "
		    << e.name << " &ref);\n";
	}

	out << "\n} // namespace OpenApoc\n";
}

void writeSource(std::ofstream &out, const StateDefinition &state)
{
	out << "// GENERATED SOURCE - generated by GamestateSerializeGen - do not modify directly\n\n";
	out << "#include \"framework/serialization/serialize.h\"\n";
	out << "#include \"game/state/gamestate_serialize.h\"\n";
	out << "#include \"game/state/gamestate_serialize_generated.h\"\n\n";

	out << "namespace OpenApoc {\n\n";

	for (auto &object : state.objects)
	{
		if (object.external == true)
			continue;
		out << "inline void serializeIn(const GameState *, SerializationNode* node, " << object.name
		    << " &obj);\n";
		out << "inline void serializeOut(SerializationNode* node, const " << object.name
		    << " &obj, const " << object.name << " &ref);\n";
		out << "inline bool operator==(const " << object.name << " &a, const " << object.name
		    << " &b);\n";
		out << "inline bool operator!=(const " << object.name << " &a, const " << object.name
		    << " &b);\n\n";
	}

	for (auto &e : state.enums)
	{
		if (e.external == true)
			continue;
		out << "inline void serializeIn(const GameState *, SerializationNode* node, " << e.name
		    << " &val);\n";
		out << "inline void serializeOut(SerializationNode* node, const " << e.name
		    << " &val, const " << e.name << " &ref);\n";
	}
	for (auto &object : state.objects)
	{
		if (object.external == false)
			out << "inline\n";
		out << "void serializeIn(const GameState *state, SerializationNode* node, " << object.name
		    << " &obj)\n{\n";

		out << "\tif (!node) return;\n";

		for (auto &member : object.members)
		{
			std::string serializeFn;
			std::string newNodeFn;
			switch (member.second.type)
			{
				case NodeType::Normal:
					serializeFn = "serializeIn";
					newNodeFn = "getNode";
					break;
				case NodeType::Section:
					serializeFn = "serializeIn";
					newNodeFn = "getSection";
					break;
				case NodeType::SectionMap:
					serializeFn = "serializeInSectionMap";
					newNodeFn = "getSection";
					break;
			}
			out << "\t" << serializeFn << "(state, node->" << newNodeFn << "(\"" << member.first
			    << "\"), obj." << member.first << ");\n";
		}

		out << "}\n";

		if (object.external == false)
			out << "inline\n";
		out << "void serializeOut(SerializationNode* node, const " << object.name << " &obj, const "
		    << object.name << " &ref)\n{\n";

		for (auto &member : object.members)
		{
			std::string serializeFn;
			std::string newNodeFn;
			switch (member.second.type)
			{
				case NodeType::Normal:
					serializeFn = "serializeOut";
					newNodeFn = "addNode";
					break;
				case NodeType::Section:
					serializeFn = "serializeOut";
					newNodeFn = "addSection";
					break;
				case NodeType::SectionMap:
					serializeFn = "serializeOutSectionMap";
					newNodeFn = "addSection";
					break;
			}
			if (object.full)
			{
				out << "\t" << serializeFn << "(node->" << newNodeFn << "(\"" << member.first
				    << "\"), obj." << member.first << ", ref." << member.first << ");\n";
			}
			else
			{
				out << "\tif (obj." << member.first << " != ref." << member.first << ")"
				    << serializeFn << "(node->" << newNodeFn << "(\"" << member.first << "\"), obj."
				    << member.first << ", ref." << member.first << ");\n";
			}
		}

		out << "}\n";

		if (object.external == false)
			out << "inline\n";
		out << "bool operator==(const " << object.name << " &a, const " << object.name
		    << " &b)\n{\n";

		for (auto &member : object.members)
		{
			out << "\tif (a." << member.first << " != b." << member.first << ") { return false;}\n";
		}

		out << "\treturn true;\n}\n";

		if (object.external == false)
			out << "inline\n";
		out << "bool operator!=(const " << object.name << " &a, const " << object.name
		    << " &b)\n{\n\treturn !(a == b);\n}\n";
	}

	for (auto &e : state.enums)
	{
		if (e.external == false)
			out << "inline\n";
		out << "void serializeIn(const GameState *state, SerializationNode* node, " << e.name
		    << " &val)\n{\n"
		    << "\tstatic const std::map<" << e.name << ", UString> valueMap = {\n";
		for (auto &value : e.values)
		{
			out << "\t\t{" << e.name << "::" << value << ", \"" << value << "\"},\n";
		}
		out << "\t};\n";

		out << "\tserializeIn(state, node, val, valueMap);\n"
		    << "}\n";

		if (e.external == false)
			out << "inline\n";
		out << "void serializeOut(SerializationNode* node, const " << e.name << " &val, const "
		    << e.name << " &ref)\n{\n"
		    << "\tstatic const std::map<" << e.name << ", UString> valueMap = {\n";
		for (auto &value : e.values)
		{
			out << "\t\t{" << e.name << "::" << value << ", \"" << value << "\"},\n";
		}
		out << "\t};\n";

		out << "\tserializeOut(node, val, ref, valueMap);\n"
		    << "}\n";
	}
	out << "\n} // namespace OpenApoc\n";
}

int main(int argc, char **argv)
{

	po::options_description desc("Allowed options");
	// These operator() really screw up clang-format
	// clang-format off
	desc.add_options()
		("help", "Show help message")
		("xml,x", po::value<std::string>(),"Input XML file")
		("output-header,h", po::value<std::string>(), "Path to output generated header file")
		("output-source,o", po::value<std::string>(), "Path to output generated source file")
	;
	// clang-format on

	po::variables_map vm;
	po::store(po::parse_command_line(argc, argv, desc), vm);
	po::notify(vm);

	std::string inputXmlPath;
	std::string outputHeaderPath;
	std::string outputSourcePath;

	if (vm.count("help"))
	{
		std::cout << desc << "\n";
		return 1;
	}
	if (!vm.count("xml"))
	{
		std::cerr << "Must specify input XML file\n" << desc << "\n";
		return 1;
	}
	if (!vm.count("output-header"))
	{
		std::cerr << "Must specify output header file\n" << desc << "\n";
		return 1;
	}
	if (!vm.count("output-source"))
	{
		std::cerr << "Must specify output source file\n" << desc << "\n";
		return 1;
	}

	inputXmlPath = vm["xml"].as<std::string>();
	outputHeaderPath = vm["output-header"].as<std::string>();
	outputSourcePath = vm["output-source"].as<std::string>();

	std::ifstream inputXmlFile(inputXmlPath);
	if (!inputXmlFile)
	{
		std::cerr << "Failed to open input XML file \"" << inputXmlPath << "\"\n";
		return 1;
	}

	std::ofstream outputSourceFile(outputSourcePath);
	if (!outputSourceFile)
	{
		std::cerr << "Failed to open output source file at \"" << outputSourcePath << "\"\n";
		return 1;
	}

	std::ofstream outputHeaderFile(outputHeaderPath);
	if (!outputHeaderFile)
	{
		std::cerr << "Failed to open output header file at \"" << outputHeaderPath << "\"\n";
		return 1;
	}

	StateDefinition state;
	if (!readXml(inputXmlFile, state))
	{
		std::cerr << "Reading input XML file \"" << inputXmlPath << "\" failed\n";
		return 1;
	}

	writeHeader(outputHeaderFile, state);
	writeSource(outputSourceFile, state);

	return 0;
}
